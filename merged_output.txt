--- src\main\db.ts ---
// src/main/db.ts データベースを初期化するファイル
import path from 'path';
import { app } from 'electron';
import knex from 'knex';

// データベースのインスタンスを作成
export const db = knex({
  client: 'sqlite3',
  connection: {
    filename: path.join(app.getPath('userData'), 'database.sqlite'),
  },
  useNullAsDefault: true,
});

// テーブル作成関数
export async function setupDatabase() {
  const exists = await db.schema.hasTable('users');
  if (!exists) {
    await db.schema.createTable('users', (table) => {
      table.increments('id').primary();
      table.string('name');
      table.integer('age');
    });
  }
}


--- src\main\index.ts ---
import { app, shell, BrowserWindow} from 'electron'
import path from 'path'
import { electronApp, optimizer, is } from '@electron-toolkit/utils'
import icon from '../../resources/icon.png?asset'

function createWindow(): void {
  const mainWindow = new BrowserWindow({
    width: 900,
    height: 670,
    show: false,
    autoHideMenuBar: true,
    ...(process.platform === 'linux' ? { icon } : {}),
    webPreferences: {
      preload: path.join(__dirname, '../preload/index.js'),
      sandbox: false,
    },
    minWidth:900,
    minHeight: 670,
  });

  mainWindow.on('ready-to-show', () => {
    mainWindow.show()
  })

  mainWindow.webContents.setWindowOpenHandler((details) => {
    shell.openExternal(details.url)
    return { action: 'deny' }
  })

  // HMR for renderer base on electron-vite cli.
  // Load the remote URL for development or the local html file for production.
  if (is.dev && process.env['ELECTRON_RENDERER_URL']) {
    mainWindow.loadURL(process.env['ELECTRON_RENDERER_URL'])
  } else {
    mainWindow.loadFile(path.join(__dirname, '../renderer/index.html'))
  }
}

app.whenReady().then(() => {
  electronApp.setAppUserModelId('com.electron')

  app.on('browser-window-created', (_, window) => {
    optimizer.watchWindowShortcuts(window)
  })

  createWindow()

  app.on('activate', function () {
    if (BrowserWindow.getAllWindows().length === 0) createWindow()
  })
})

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

--- src\main\ipc.ts ---
// src/main/ipc.ts IPC通信を設定するファイル
import { ipcMain } from 'electron';
import { db } from './db';

// ユーザーデータを取得
ipcMain.handle('get-users', async () => {
  return await db('users').select('*');
});

// ユーザーを追加
ipcMain.handle('add-user', async (_event, user) => {
  return await db('users').insert(user);
});


--- src\preload\index.d.ts ---
import { ElectronAPI } from '@electron-toolkit/preload'

export interface API {
  fetchUsers: () => Promise<{ id: number; name: string; age: number }[]>;
  addUser: (user: { name: string; age: number }) => Promise<void>;
}

declare global {
  interface Window {
    electron: ElectronAPI
    api: API
  }
}


--- src\preload\index.ts ---
// src/preload/index.ts
import { contextBridge, ipcRenderer } from 'electron';
import { electronAPI } from '@electron-toolkit/preload';

// Custom APIs for renderer
const api = {
  fetchUsers: async () => {
    return await ipcRenderer.invoke('get-users'); // メインプロセスのget-usersを呼び出し
  },
  addUser: async (user: { name: string; age: number }) => {
    return await ipcRenderer.invoke('add-user', user); // メインプロセスのadd-userを呼び出し
  },
};

// Use `contextBridge` APIs to expose Electron APIs to
// renderer only if context isolation is enabled, otherwise
// just add to the DOM global.
if (process.contextIsolated) {
  try {
    contextBridge.exposeInMainWorld('electron', electronAPI);
    contextBridge.exposeInMainWorld('api', api);
  } catch (error) {
    console.error(error);
  }
} else {
  // @ts-ignore (define in dts)
  window.electron = electronAPI;
  // @ts-ignore (define in dts)
  window.api = api;
}


--- src\renderer\index.html ---
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>WebDesignApp</title>
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:"
    />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


--- src\renderer\src\App.tsx ---
import React, {useEffect} from "react";
import {Box, Grid, GridItem} from "@chakra-ui/react"
import SideBar from "./components/MyDrawer";
import TaskArea from "./components/Areas/TaskArea";
import NewsArea from "./components/Areas/NewsArea";
import SessionArea from "./components/Areas/SessionArea";
import "./style/scroll.css";
import {test_news, test_sessions, test_tasks} from "./testData";
import StopwatchDisplay from "./components/Dialogs/StopwatchDisplay";
import {formatStopWatchTime} from "./util/formatStopWatchTime";
import {useStopwatchContext} from "./context/StopwatchContext";
import {useTaskContext} from "./context/TaskContext";

function DataFetcher(){
    const {addTask,taskData} = useTaskContext();
    useEffect(() => {
        let ignore = false;
        if(!ignore) addTask(test_tasks);
        console.log(taskData);
        return () => {
            ignore = true;
        };
    }, []);
}


function App(): React.ReactElement {
    const {
        isRunning,
        isMinimum,
        currentTime,
        finishStopwatch,
    } = useStopwatchContext();

    const {addTask,taskNow} = useTaskContext();

    useEffect(() => {
        let ignore = false;
        if(!ignore) addTask(test_tasks);
        return () => {
            ignore = true;
        };
    }, []);

    return (
        <Box bg={"orange.50"} w={"100%"} h={"100vh"}
             colorPalette={"orange"}
        >
            {
                isRunning && isMinimum &&
                <StopwatchDisplay
                    time={formatStopWatchTime(currentTime)}
                    task={taskNow?.task}
                    onFinish={finishStopwatch}
                />
            }
            <SideBar>
                <Grid
                    h="100%"
                    templateRows="minmax(min-content, auto) minmax(10px, 1fr)"
                    templateColumns="repeat(4, 1fr)"
                    p={2}
                    pt={8}
                    gap={3}
                >
                    <GridItem  colSpan={4}>
                        <TaskArea/>
                    </GridItem>
                    <GridItem  colSpan={2}>
                        <SessionArea sessions={test_sessions}/>
                    </GridItem>
                    <GridItem  colSpan={2}>
                        <NewsArea　news={test_news} />
                    </GridItem>
                </Grid>
            </SideBar>
        </Box>
    );
}

export default App


--- src\renderer\src\env.d.ts ---


--- src\renderer\src\main.tsx ---
import React, {useEffect} from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import {Provider} from "./ui/provider"
import '@fontsource/zen-maru-gothic';
import {createTheme,ThemeProvider} from "@mui/material";
import {createSystem, defaultConfig} from "@chakra-ui/react";
import { StopwatchProvider } from "./context/StopwatchContext";
import {DialogsProvider} from "./context/DialogsContext";
import {TaskProvider} from "./context/TaskContext";
import TaskCreate from "./test/tasktest";

const theme = createTheme({
    typography:{
        fontFamily:"'Zen Maru Gothic',system-ui",
    }
});
const system = createSystem(defaultConfig, {
    theme: {
        tokens: {
            fonts: {
                heading: { value: "'Zen Maru Gothic',system-ui" },
                body: { value: "'Zen Maru Gothic',system-ui" },
            },
        },
    },
})

// プロバイダー十把一絡げ
function MyProviders({children}: {children: React.ReactNode}) {
    return (
        <TaskProvider>
            <StopwatchProvider>
                <DialogsProvider>
                    {children}
                </DialogsProvider>
            </StopwatchProvider>
        </TaskProvider>
    );
}

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
    <React.StrictMode>
        <ThemeProvider theme={theme}>
            <Provider system={system}>
                <MyProviders>
                    {/*<TaskCreate/>*/}
                    <App/>
                </MyProviders>
            </Provider>
        </ThemeProvider>
    </React.StrictMode>
)


--- src\renderer\src\testData.ts ---
import {Sessions} from "./components/Areas/SessionArea";
import {getImage} from "./util/getImage";
import {TaskItem} from "./context/TaskContext";

export const test_sessions :Sessions[] = [
    {
        start_unix:1609426800,
        stop_unix :1609513200,
        start_iso :"2020-01-01 00:00:00",
        stop_iso  :"2020-01-02 00:00:00",
        task      :"食べる",
        posts:[
            {
                date_unix: 1609426860,
                date_iso: "2020-01-03 00:00:00",
                postMessage: "あいうえおあいうえお\nあいうえおあいうえおあいうえお",
                reply: {
                    date_unix: 1609426860,
                    date_iso: "2020-01-03 00:00:00",
                    replyName: "トドりん",
                    replyId: "todorin1122",
                    avatar: getImage("todo.png"),
                    message:
                        "これはクライアントには出せないかなぁ。\n" +
                        "帰属意識は大事だけど視野狭窄になってない？\n" +
                        "昇格はちょっと厳しくなったかもね。\n"
                },
            }
        ],
    },
    {
        posts:[
            {
                date_unix: 1609426860,
                date_iso: "2020-01-03 00:00:00",
                postMessage: "あいうえおあいうえお\nあいうえおあいうえおあいうえお",
                reply: {
                    date_unix: 1609426860,
                    date_iso: "2020-01-03 00:00:00",
                    replyName: "トドりん",
                    replyId: "todorin1122",
                    avatar: getImage("todo.png"),
                    message:
                        "これはクライアントには出せないかなぁ。\n" +
                        "帰属意識は大事だけど視野狭窄になってない？\n" +
                        "昇格はちょっと厳しくなったかもね。\n"
                },
            }
        ]
    }
];

export const test_tasks:TaskItem[] = [
    {
        date_unix:1234567768,
        task:"食べる"
    },
    {
        date_unix:1234567768,
        task:"食べる"
    },
    {
        date_unix:1234567768,
        task:"食す"
    },
    {
        date_unix:1234567768,
        task:"食む"
    },
    {
        date_unix:2783423840,
        task:"食べる"
    },

];

export const test_news:string[]=[
    // "チャイティーがミルクティーの一種だったことを知らずに注文しむせた",
    // "チャイティーがミルクティーの一種だったことを知らずに注文しむせた",
    // "チャイティーがミルクティーの一種だったことを知らずに注文しむせた",
    // "チャイティーがミルクティーの一種だったことを知らずに注文しむせた",
    // "チャイティーがミルクティーの一種だったことを知らずに注文しむせた",
]

--- src\renderer\src\assets\todo.png ---
--- src\renderer\src\assets\困ったトド.png ---
--- src\renderer\src\components\Area.tsx ---
import {Box, Heading, HTMLChakraProps} from "@chakra-ui/react";

export function Area(props:HTMLChakraProps<"div">) {
    const {children,w,h,bg,display,title,...other} = props;

    return(
        <Box
            w={w?w:"100%"} h={h?h:"100%"}
            bg={"orange.200"}
            rounded={"xl"}
            padding={"3"}
            color={"orange.950"}
            display={"grid"}
            gridTemplateRows={"fit-content(100%) 1fr"}
            {...other}
        >
            {children}
        </Box>
    );
}

export function AreaHeader({children}:{children:string}){
    return (
        <Heading size="xl" h={"fit-content"} marginBottom={"1"}>
            {children}
        </Heading>
    );
}
export function AreaBody(props:HTMLChakraProps<"div">){
    const {display,children,...other} = props;
    return (
        <Box w={"100%"} h={"100%"}
             bgColor={"orange.50"}
             rounded={"xl"}
             shadow={"md"}
             display={display?display:"grid"}
             {...other}
        >
            {children}
        </Box>
    );
}


--- src\renderer\src\components\MyDialog.tsx ---
import {
    DialogBody, DialogCloseTrigger,
    DialogContent,
    DialogFooter,
    DialogHeader,
    DialogRoot,
    DialogTitle,
    DialogTrigger
} from "../ui/dialog";
import {
    DialogBodyProps,
    DialogContentProps, DialogFooterProps,
    DialogHeaderProps,
    DialogRootProps,
    HTMLChakraProps,
} from "@chakra-ui/react";
import React from "react";
import Draggable from "react-draggable";

namespace MyDialog {

    export function Root(props:DialogRootProps) {
        const {children,...other} = props;

        return(
            <DialogRoot {...other}>
                {children}
            </DialogRoot>
        );
    }

    export function Trigger({children}:{children:React.ReactNode}) {
        return (
            <DialogTrigger asChild>
                {children}
            </DialogTrigger>
        )
    }

    export function Content(props:DialogContentProps&HTMLChakraProps<"div">) {
        const {children, ...other} = props;
        const nodeRef = React.useRef<HTMLDivElement>(null);

        return(
            <Draggable nodeRef={nodeRef}>
                <DialogContent {...other} ref={nodeRef}>
                    {children}
                    <DialogCloseTrigger
                        size={"xl"}
                        _hover={{
                            bg:"blackAlpha.200"
                        }}
                    />
                </DialogContent>
            </Draggable>
        )
    }

    export function Header(props:DialogHeaderProps&HTMLChakraProps<"div">) {
        const {children, ...other} = props;
        return(
            <DialogHeader>
                <DialogTitle {...other}>{children}</DialogTitle>
            </DialogHeader>
        )
    }
    export function Body(props:DialogBodyProps&React.RefAttributes<HTMLDivElement>) {
        const {children, ...other} = props;
        return(
            <DialogBody {...other}>
                {children}
            </DialogBody>
        );
    }

    export function Footer(props:DialogFooterProps&HTMLChakraProps<"div">) {
        const {children, ...other} = props;
        return(
            <DialogFooter {...other}>
                {children}
            </DialogFooter>
        );
    }
}

export default MyDialog;

--- src\renderer\src\components\MyDrawer.tsx ---
import * as React from 'react';
import {useTheme} from '@mui/material/styles';
import Drawer from '@mui/material/Drawer';
import CssBaseline from '@mui/material/CssBaseline';
import Divider from '@mui/material/Divider';
import ChevronLeftIcon from '@mui/icons-material/ChevronLeft';
import ChevronRightIcon from '@mui/icons-material/ChevronRight';
import BestBoutArea from "./Areas/BestBoutArea";
import {HTMLChakraProps, Text, Box, IconButton} from "@chakra-ui/react";
import {CommandList} from "./SideBar/CommandList";
import {MainViewer} from "./SideBar/MainViewer";
import {CommandBar} from "./SideBar/CommandBar";

const drawerWidth = 280;

function DrawerHeader({ children,...other }:HTMLChakraProps<"div">) {
    return (
        <Box
            display="flex"
            alignItems="center"
            px={1} // 左右のパディング
            py={3} // 上下のパディング
            justifyContent="space-between"
            {...other}
        >
            {children}
        </Box>
    );
}

export function SideBar({children}:{children:React.ReactNode}) {
    const theme = useTheme();
    const [open, setOpen] = React.useState(true);
    const [isCommandBarVisible, setIsCommandBarVisible] = React.useState(false);

    const handleDrawerOpen = () => {
        setOpen(true);
    };

    const handleDrawerClose = () => {
        setOpen(false);
    };

    React.useEffect(() => {
        // Drawerのopen/closeとAppBarの表示をずらす
        if (open) {
            setIsCommandBarVisible(false);
            return ()=>{};
        } else {
            const timer = setTimeout(() => {
                setIsCommandBarVisible(true);
            },200);
            return () => clearTimeout(timer); // クリーンアップ
        }
    },[open]);

    return (
        <Box display={"flex"}>
            <CssBaseline />
            <CommandBar
                open={open}
                drawerWidth={drawerWidth}
                handleDrawerOpen={handleDrawerOpen}
                isVisible={isCommandBarVisible}
            />
            <Drawer
                sx={{
                    width: drawerWidth,
                    flexShrink: 0,
                    '& .MuiDrawer-paper': {
                        width: drawerWidth,
                        boxSizing: 'border-box',
                        backgroundColor: "transparent",
                        color:"#220a04"
                    },
                }}
                variant="persistent"
                anchor="left"
                open={open}
            >
                <DrawerHeader>
                    <Text textStyle={"2xl"} w={"100%"} pl={"1em"}>
                        アプリ名？
                    </Text>
                    <IconButton
                        size={"lg"}
                        bg={{
                            base: "transparent",
                            _hover:"blackAlpha.200"
                        }}
                        onClick={handleDrawerClose}
                        variant={"subtle"}
                    >
                        {theme.direction === 'ltr' ? <ChevronLeftIcon /> : <ChevronRightIcon />}
                    </IconButton>
                </DrawerHeader>
                <Divider />

                {/*コマンドエリア*/}
                <CommandList/>
                <Divider />

                {/*ベストバウトエリア*/}
                <Box width={"100%"} height={"100%"} padding={2.5} display={"flex"} alignItems={"flex-end"}>
                    <BestBoutArea data={["1月8日","2月20日","3月10日"]}/>
                </Box>
            </Drawer>
            <MainViewer
                open={open}
                drawerWidth={drawerWidth}
            >
                <Box h={"100%"} width={"100%"}>
                    {children}
                </Box>
            </MainViewer>
        </Box>
    );
}



export default SideBar;

--- src\renderer\src\components\Speech.tsx ---
import { Box, Flex, Text } from "@chakra-ui/react";
import todo from '../assets/todo.png';
import {Avatar} from "../ui/avatar";

export function Speech({children}:{children:string}) {
    return (
        <Flex
            alignItems="center"
            gap={5}
        >
            <Avatar size={"lg"} name="Todorin" src={todo} overflow={"clip"} overflowClipMargin={"content-box"} />
            <Box
                position="relative"
                bg="#f9f9f9"
                p="10px 15px"
                rounded={"lg"}
                lineHeight="1.4"
                _before={{
                    content: '""',
                    position: "absolute",
                    top: "50%",
                    left: "-10px",
                    transform: "translateY(-50%)",
                    width: "0",
                    height: "0",
                    borderStyle: "solid",
                    borderWidth: "10px 10px 10px 0",
                    borderColor: "transparent #f9f9f9 transparent transparent",
                }}
            >
                <Text>{children}</Text>
            </Box>
        </Flex>
    );
}


--- src\renderer\src\components\Areas\BestBoutArea.tsx ---
import {For, List} from "@chakra-ui/react";
import {Area,AreaHeader,AreaBody} from "../Area";

export default function BestBoutArea({data}:{data:string[]}) {
    return(
        <Area h={"fit-content"}>
            <AreaHeader>Best Days</AreaHeader>
            <AreaBody padding={"5"}>
                <List.Root as={"ol"} fontSize={"2xl"}  justifyContent="space-between" gap={5}>
                    <For each={data}>
                        {(item,index)=><List.Item key={`BestBoutArea_List${index}`}>{item}</List.Item>}
                    </For>
                </List.Root>
            </AreaBody>
        </Area>
    );
}

--- src\renderer\src\components\Areas\NewsArea.tsx ---
import {Area, AreaBody, AreaHeader} from "../Area";
import {Speech} from "../Speech";
import {For, VStack} from "@chakra-ui/react";
import { TbMoodSadSquint } from "react-icons/tb";
import {EmptyState} from "../../ui/empty-state";

export default function NewsArea({news}:{news:string[]}) {
    return(
        <Area>
            <AreaHeader>ニュース</AreaHeader>
            {news.length > 0
                ? (
                    <VStack
                        p={4}
                        w={"full"}
                        bg={"transparent"}
                        overflowY={"auto"}
                        alignItems={"left"}
                        gap={4}
                    >
                        <For each={news}>
                            {(item, index)=>(
                                <Speech key={`Speech_${index}`}>
                                    {`「${item}」`}
                                </Speech>
                            )}
                        </For>

                    </VStack>
                )
                : (
                    <AreaBody>
                        <EmptyState
                            icon={<TbMoodSadSquint/>}
                            title={"ニュースがないよ～"}
                            color={"orange.900"}
                            size={"lg"}
                        />
                    </AreaBody>
                )
            }
        </Area>
    );
}

--- src\renderer\src\components\Areas\SessionArea.tsx ---
import {Area,AreaHeader,AreaBody} from "../Area";
import {TimelineConnector, TimelineContent, TimelineDescription, TimelineItem, TimelineRoot, TimelineTitle} from "../../ui/timeline"
import { FaRegPenToSquare } from "react-icons/fa6";
import { LuPlay,LuPause } from "react-icons/lu";
import {Card, CardBodyProps, For, HStack, Text, VStack} from "@chakra-ui/react";
import convUnixToIso from "../../util/convUnixToIso";
import {Avatar} from "../../ui/avatar";
import calcElapsedTime from "../../util/calcElapsedTime";
import {AccordionItem, AccordionItemContent, AccordionItemTrigger, AccordionRoot} from "../../ui/accordion";
import React from "react";
import {EmptyState} from "../../ui/empty-state";
import { TbMoodSadSquint } from "react-icons/tb";

// 時間はDBからUNIXタイムスタンプを受け取るようにし、それをクライアント側で指定のフォーマットに変換するように。

// Replyの情報
export type ReplyInfo = {
    avatar   :string,
    replyName:string,
    replyId  :string,
    message  :string,
    date_unix:number,
    date_iso :string,
}
export type PostInfo = {
    date_unix   :number,
    date_iso    :string,
    postMessage :string,
    reply      ?:ReplyInfo
}

export type Sessions = {
    start_unix ?:number,
    stop_unix  ?:number,
    start_iso  ?:string,
    stop_iso   ?:string,
    task       ?:string,
    posts      :PostInfo[]
};


export default function SessionArea({sessions}:{sessions:Sessions[]}){
    return(
        <Area>
            <AreaHeader>りれき</AreaHeader>
            {sessions.length>0
                ? <VStack overflowY={"auto"} gap={3}>
                    <For each={sessions}>
                        {(item, index)=>(
                            <AreaBody
                                key={`LogArea_TimeLine_${index}`}
                                p={6}
                                pb={0}
                                h={"fit-content"}
                            >
                                <TimelineRoot  size={"lg"} maxW="400px">
                                    {(item.start_unix) && <TimeLineStart date={item.start_unix} task={item?.task}/>}
                                    <For each={item.posts}>
                                        {(item2, index2)=>(
                                            <TimeLineTopic
                                                key={`Topic_${item.start_unix}-${item.stop_unix}_${index2}`}
                                                date={item2.date_unix}
                                                topic={item2.postMessage}
                                                reply={item2.reply}
                                            />
                                        )}
                                    </For>
                                    {(item.stop_unix && item.start_unix) && <TimeLineStop
                                        date={item.stop_unix}
                                        start={item.start_unix}
                                        stop={item.stop_unix}
                                        task={item?.task}
                                    />}
                                </TimelineRoot>
                            </AreaBody>
                        )}
                    </For>
                </VStack>
                : <AreaBody>
                    <EmptyState
                        icon={<TbMoodSadSquint />}
                        title="履歴がないよ～"
                        size={"lg"}
                    >
                        <Text textStyle={"lg"} whiteSpace={"pre-wrap"} textAlign={"center"}>
                            {"サイドバーのストップウォッチから\nタスクを始めてね！"}
                        </Text>
                    </EmptyState>
                </AreaBody>
            }
        </Area>
    );
}

function TimeLineStart(props:{date:number,task?:string}){
    return(
        <TimelineItem>
            <TimelineConnector bg="teal.solid" color="teal.contrast" fontSize={"md"}>
                <LuPlay/>
            </TimelineConnector>
            <TimelineContent>
                <TimelineTitle textStyle={"sm"}>
                    {props.task && `[${props.task}]`}
                    {props.task && <br/>}
                    タスクかいし！
                </TimelineTitle>
                <TimelineDescription letterSpacing={"wide"}>
                    {convUnixToIso(props.date)}
                </TimelineDescription>
            </TimelineContent>
        </TimelineItem>
    );
}

function TimeLineStop(props:{date:number,start:number,stop:number,task?:string}){
    return (
        <TimelineItem>
            <TimelineConnector bg="pink.solid" color="pink.contrast" fontSize={"md"}>
                <LuPause/>
            </TimelineConnector>
            <TimelineContent >
                <TimelineTitle textStyle="sm">
                    {props.task && `[${props.task}]`}
                    {props.task && <br/>}
                    タスクしゅーりょー！
                </TimelineTitle>
                <Text textStyle={"sm"} color={"fg.muted"}>{`経過時間：${calcElapsedTime(props.start,props.stop)}`}</Text>
                <TimelineDescription letterSpacing={"wide"}>
                    {convUnixToIso(props.date)}
                </TimelineDescription>
            </TimelineContent>
        </TimelineItem>
    );
}

function TimeLineTopic(props:{date:number,topic:string,reply?:ReplyInfo}) {
    return (
        <TimelineItem>
            <TimelineConnector bg="blue.solid" color="blue.contrast">
                <FaRegPenToSquare/>
            </TimelineConnector>
            <TimelineContent>
                <TopicCard
                    message={props.topic}
                    date={props.date}
                    textStyle={"md"}
                    rounded={"md"}
                    borderWidth={1}
                    borderColor={"gray.200"}
                />
                {props.reply?(<ReplyAccordion {...props.reply}/>):(<></>)}
            </TimelineContent>
        </TimelineItem>
    );
}

function ReplyAccordion(props:ReplyInfo){
    const [open, setOpen] = React.useState(false);

    return (
        <AccordionRoot
            collapsible
            default
            bg={{base:"white"}}
            borderWidth={1}
            borderColor={"gray.light"}
            variant={"plain"}
            rounded={"md"}
            onValueChange={()=>setOpen(!open)}
            open={open}
        >
            <AccordionItem>
                <AccordionItemTrigger
                    pl={4}
                    pr={4}
                >
                    {open
                        ? (
                            <HStack gap={4} pt={1} pb={0}>
                                <Avatar
                                    src={props.avatar}
                                    name={props.replyName}
                                    size="lg"
                                    shape="rounded"
                                    bg={"transparent"}
                                />
                                <VStack gap={0}>
                                    <Text w={"100%"} fontWeight={"semibold"} textStyle={"sm"}>{props.replyName}</Text>
                                    <Text w={"100%"} color="fg.muted" textStyle="sm">@{props.replyId}</Text>
                                </VStack>
                            </HStack>
                        )
                        : (<Text w={"100%"} pl={2}  color={"blue.500"} fontWeight={"bold"}>返信がとどいているよ!</Text>)}
                </AccordionItemTrigger>
                <AccordionItemContent pt={1} pb={1}>
                    <TopicCard
                        message={props.message}
                        date={props.date_unix}
                        pt={0}
                        pb={4}
                    />
                </AccordionItemContent>
            </AccordionItem>
        </AccordionRoot>
    )
}

function TopicCard(props:CardBodyProps&{message:string,date:number}) {
    const {message,date,color,...other} = props;
    return (
        <Card.Root width="100%" borderWidth={0}>
            <Card.Body gap={3} {...other}>
                <Card.Description whiteSpace={"pre-wrap"} textStyle={props?.textStyle}>
                    {message}
                </Card.Description>
                <TimelineDescription letterSpacing={"wide"} color={"gray.400"}>
                    {convUnixToIso(props.date)}
                </TimelineDescription>
            </Card.Body>
        </Card.Root>
    );
}

--- src\renderer\src\components\Areas\TaskArea.tsx ---
import {Area,AreaHeader,AreaBody} from "../Area";
import {Button} from "../../ui/button";
import {Box, For, HStack, Text, VStack} from "@chakra-ui/react";
import {EmptyState} from "../../ui/empty-state";
import { TbMoodSadSquint } from "react-icons/tb";
import {useStopwatchContext} from "../../context/StopwatchContext";
import {useMyDialog} from "../../context/DialogsContext";
import {generateTaskHash, TaskItem, useTaskContext} from "../../context/TaskContext";
import {convUnixOnlyDate} from "../../util/convUnixOnlyDate";


export default function TaskArea() {
    const {isRunning} = useStopwatchContext();
    const {taskData} = useTaskContext();
    return(
        <Area>
            <AreaHeader>タスク</AreaHeader>
            <AreaBody shadow={"none"} overflowX="auto">
                {taskData.length > 0
                    ? (
                        <HStack
                            gap={4}
                            p={2}
                            pl={5}
                            pr={5}
                            overflowY="hidden"
                        >
                            <For each={taskData}>
                                {(item,index)=>{
                                    return (
                                        <Box
                                            bg={"transparent"}
                                            rounded={"md"}
                                            flexShrink={0}
                                            transition={"0.3s"}
                                            key={`TaskArea_Task${index}`}
                                        >
                                            <TaskButton
                                                date_unix={item.date_unix}
                                                task={item.task}
                                                disabled={isRunning}
                                            />
                                        </Box>
                                    );
                                }}
                            </For>
                        </HStack>
                    )
                    : (<EmptyState
                        icon={<TbMoodSadSquint/>}
                        title={"タスクがないよ～"}
                        p={2}
                        color={"orange.900"}
                    />)}
            </AreaBody>
        </Area>
    );
}


function TaskButton(data:TaskItem&{disabled:boolean}){
    const { openDialog } = useMyDialog();
    const {taskNowHandler} = useTaskContext();
    const today = convUnixOnlyDate(data.date_unix);
    const {disabled,...date} = data;
    return (
        <>
            <Button
                width={"100px"}
                height={"fit-content"}
                display={"grid"}
                alignItems={"center"}
                textAlign={"center"}
                p={1}
                rounded={"md"}
                bg={{
                    base:"orange.200/50",
                    _active:"orange.400"
                }}
                boxShadow={{
                    base:"0px 4px 0px slategray",
                    _hover:"none"
                }}
                translate={{
                    _hover:"0px 4px"
                }}
                borderWidth={2}
                borderColor={"orange.700"}
                color={"black"}
                fontWeight={"bold"}
                _active={{
                }}
                colorPalette={"orange"}
                disabled={disabled}
                onClick={() => {
                    taskNowHandler({
                        ...date,
                        task_hush:generateTaskHash(date)
                    });
                    openDialog('StopWatch')
                }}
            >
                <VStack gap={1} w={"80px"}>
                    <Text>{today}</Text>
                    <Text
                        w={"100%"}
                        whiteSpace={"nowrap"}
                        overflowX={"hidden"}
                        textOverflow={"ellipsis"}
                    >{date.task}</Text>
                </VStack>
            </Button>
        </>
    );
}

--- src\renderer\src\components\Dialogs\AddLog.tsx ---
import MyDialog from "../MyDialog";
import {Text} from "@chakra-ui/react";

interface Props {
    closeDialog: () => void;
    isOpen: boolean;
}

export function AddLog(props:Props) {
    return(
        <MyDialog.Root
            open={props.isOpen}
            closeOnInteractOutside={false}
            onOpenChange={props.closeDialog}
        >
            <MyDialog.Content>
                <MyDialog.Header>
                    記録
                </MyDialog.Header>
                <MyDialog.Body>
                    <Text>
                        ここには
                        <br/>
                        ダイアログの内容が
                        <br/>
                        入るよ
                    </Text>
                </MyDialog.Body>
                <MyDialog.Footer>

                </MyDialog.Footer>
            </MyDialog.Content>
        </MyDialog.Root>
    );
}

--- src\renderer\src\components\Dialogs\AddTask.tsx ---
import MyDialog from "../MyDialog";
import {Text} from "@chakra-ui/react";

interface Props {
    closeDialog: () => void;
    isOpen: boolean;
}

export function AddTask(props:Props) {
    return(
        <MyDialog.Root
            open={props.isOpen}
            closeOnInteractOutside={false}
            onOpenChange={props.closeDialog}
        >
            <MyDialog.Content>
                <MyDialog.Header>
                    タスクついか
                </MyDialog.Header>
                <MyDialog.Body>
                </MyDialog.Body>
                <MyDialog.Footer>

                </MyDialog.Footer>
            </MyDialog.Content>
        </MyDialog.Root>
    );
}

--- src\renderer\src\components\Dialogs\StopWatch.tsx ---
import MyDialog from "../MyDialog";
import {createListCollection, Heading,VStack} from "@chakra-ui/react";
import { Button } from "../../ui/button";
import { useStopwatchContext } from "../../context/StopwatchContext";
import {formatStopWatchTime} from "../../util/formatStopWatchTime";
import {OpenChangeDetails} from "@zag-js/dialog";
import {DialogActionTrigger} from "../../ui/dialog";
import {SelectContent, SelectItem, SelectLabel, SelectRoot, SelectTrigger, SelectValueText } from "../../ui/select";
import {useTaskContext} from "../../context/TaskContext";
import {convUnixOnlyDate} from "../../util/convUnixOnlyDate";

interface Props {
    closeDialog: () => void;
    isOpen: boolean;
}

export function StopWatch(props: Props) {
    // ストップウォッチの状態を管理
    const {
        currentTime,
        isRunning,
        startStopwatch,
        finishStopwatch,
        setIsMinimum,
    } = useStopwatchContext();
    return (
        <>
            <MyDialog.Root
                open={props.isOpen}
                closeOnInteractOutside={false}
                onOpenChange={(details: OpenChangeDetails)=>{
                    setIsMinimum(!details.open);
                    props.closeDialog();
                }}
            >
                <MyDialog.Content h={"450px"} bg={"orange.50"}>
                    <MyDialog.Header>ストップウォッチ</MyDialog.Header>
                    <MyDialog.Body pb={2} >
                        <VStack justify="space-between" gap={4}>
                            <Heading
                                size={"6xl"}
                                textAlign={"center"}
                                letterSpacing={4}
                                py={7}
                            >
                                {formatStopWatchTime(currentTime)}
                            </Heading>
                            <TaskSelect/>
                        </VStack>
                    </MyDialog.Body>
                    <MyDialog.Footer justifyContent={"center"} pb={10}>
                        {isRunning ? (
                            <DialogActionTrigger asChild>
                                <Button
                                    size={"xl"}
                                    onClick={finishStopwatch}
                                    variant="outline"
                                    colorPalette="red"
                                >
                                    フィニッシュ
                                </Button>
                            </DialogActionTrigger>
                        ) : (
                            <Button
                                size={"xl"}
                                onClick={startStopwatch}
                                variant="solid"
                                colorPalette="green"
                            >
                                スタート
                            </Button>
                        )}
                    </MyDialog.Footer>
                </MyDialog.Content>
            </MyDialog.Root>
        </>
    );
}

function TaskSelect(){
    const {taskNow,taskData,taskNowHandler} = useTaskContext();
    const {isRunning} = useStopwatchContext();
    const frameworks = createListCollection({
        items: taskData.map((task) =>{
            const today = convUnixOnlyDate(task.date_unix);
            return {label:`[${today}] ${task.task}`,value:task.task_hush};
        }),
    });
    return(
        <SelectRoot
            collection={frameworks}
            size="lg"
            width="80%"
            colorPalette={"orange"}
            disabled={isRunning}
            defaultValue={[taskNow?.task_hush]}
            onValueChange={(details)=>{
                const taskTarget = taskData.filter((task)=>task.task_hush === details.value)[0];
                taskNowHandler(taskTarget);
            }}
        >
            <SelectLabel textStyle={"lg"}>タスク</SelectLabel>
            <SelectTrigger
                bg={"orange.100/60"}
                borderWidth={1}
                borderColor={{
                    base:"orange.100",
                    _focusWithin:"orange.500",
                }}
            >
                <SelectValueText placeholder="タスクを選択" />
            </SelectTrigger>
            <SelectContent zIndex={9999} bg={"orange.100"}>
                {frameworks.items.map((data) => (
                        <SelectItem
                            item={data}
                            key={data.value}
                            bg={{
                                _hover:"orange.200",
                                _selected:"orange.300"
                            }}
                        >
                            {data.label}
                        </SelectItem>
                ))}
            </SelectContent>
        </SelectRoot>
    )
}

--- src\renderer\src\components\Dialogs\StopwatchDisplay.tsx ---
// import * as React  from 'react';
import {Box, Text, IconButton, HStack} from '@chakra-ui/react';
import { FaStop } from "react-icons/fa6";
import Draggable from 'react-draggable';
import React from "react";

interface DisplayProps {
    time:string;
    task?:string;
    onFinish:()=>void;
}

export default function StopwatchDisplay(props:DisplayProps) {
    const nodeRef = React.useRef(null);
    // const [isCommentOpen, setIsCommentOpen] = React.useState(false);
    // const [comment, setComment] = React.useState("");

    // isRunning === trueのときだけ表示
    return (
        <Draggable nodeRef={nodeRef}>
            <Box
                position="fixed"
                top="10px"
                left="10px"
                bg="orange.100"
                minW={"150px"}
                w={"fit-content"}
                borderRadius="md"
                boxShadow="md"
                zIndex={9999} // 常に前面に表示するため
                alignItems="center"
                textStyle={"xl"}
                px={2}
                py={1}
                ref={nodeRef}
            >
                <HStack
                    gap={2}
                    justifyContent="space-between"
                >
                    <Box w={"100%"} justifyContent={"center"} textAlign={"center"}>
                        <Text fontWeight="bold" letterSpacing={2}>
                            {props.task && `[${props.task}]`}
                            {props.task && <br/>}
                            {props.time}
                        </Text>
                    </Box>
                    <IconButton
                        onClick={props.onFinish}
                        size="md"
                        textStyle={"2xl"}
                        color={"red.500"}
                        bg={{
                            base:"transparent",
                            _hover:"blackAlpha.200"
                        }}
                        p={1}
                    >
                        <FaStop />
                    </IconButton>
                </HStack>
            </Box>
        </Draggable>
    );
}


--- src\renderer\src\components\Dialogs\Tweet.tsx ---
import MyDialog from "../MyDialog";
import {Textarea,Text} from "@chakra-ui/react";
import * as React from "react";
import { Button } from "../../ui/button";
import {DialogActionTrigger} from "../../ui/dialog";
import convUnixToIso from "../../util/convUnixToIso";
import {PostInfo} from "../Areas/SessionArea";

interface Props {
    closeDialog: () => void;
    isOpen: boolean;
}

export function Tweet(props:Props) {
    const [value, setValue] = React.useState("");
    const onChangeTextArea = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
        setValue(e.target.value);
    }
    const onClickButton = () => {
        alert(value);
        setValue("");
        const message = value;
        const nowTimeUNIX = (new Date()).valueOf();
        const nowTimeISO = convUnixToIso(nowTimeUNIX);
        // 投稿
        const post:PostInfo = {
            date_iso :nowTimeISO,
            date_unix:nowTimeUNIX,
            postMessage:message,
        }
        console.log(post)
    }
    const ref = React.useRef<HTMLTextAreaElement>(null);
    return(
        <MyDialog.Root
            open={props.isOpen}
            closeOnInteractOutside={false}
            initialFocusEl={() => ref.current}
            size={"lg"}
            onOpenChange={props.closeDialog}
        >
            <MyDialog.Content colorPalette={"orange"} bg={"orange.100"}>
                <MyDialog.Header>
                    <Text textStyle={"2xl"}>
                        つぶやき
                    </Text>
                </MyDialog.Header>
                <MyDialog.Body pb={3}>
                    <Textarea
                        name="tweet"
                        onChange={onChangeTextArea}
                        textStyle={"2xl"}
                        color={"black"}
                        bg={"white"}
                        minHeight={250}
                        resize={"none"}
                        fontWeight={"500"}
                        letterSpacing={0.1}
                        placeholder={"いまどうしてる？"}
                        ref={ref}
                    />
                </MyDialog.Body>
                <MyDialog.Footer>
                    <DialogActionTrigger asChild>
                        <Button
                            bg={"orange.solid"}
                            color={"orange.contrast"}
                            type="submit"
                            alignSelf="flex-start"
                            size={"lg"}
                            onClick={onClickButton}
                            disabled={!value}
                            fontWeight={"bold"}
                        >
                            Submit
                        </Button>
                    </DialogActionTrigger>
                </MyDialog.Footer>
            </MyDialog.Content>
        </MyDialog.Root>
    );
}

--- src\renderer\src\components\MyDatePicker\datePickerStyle.css ---
/* styles.css */

/* カレンダーの枠線と背景色 */
.react-date-picker {
    border: 2px solid #FFA500; /* オレンジ色 */
    border-radius: 8px;
    padding: 10px;
    background-color: #FFF8E1; /* 優しいオレンジ背景 */
}

/* 入力フィールドのスタイル */
.react-date-picker__inputGroup__input {
    padding: 10px;
    font-size: 16px;
    border-radius: 4px;
    border: 2px solid #FFA500;
    background-color: #FFECB3;
    color: #333;
}

.react-date-picker__inputGroup__input:focus {
    outline: none;
    border-color: #FF7043; /* フォーカス時に色を変える */
    background-color: #FFE0B2;
}

/* カレンダーのポップアップ背景色 */
.react-date-picker__calendar {
    background-color: #FFEB3B; /* 明るい黄色の背景 */
    border-radius: 8px;
    padding: 10px;
}

/* 月日選択のハイライト */
.react-date-picker__calendar__month {
    color: #FF5722; /* オレンジレッド */
}

.react-date-picker__calendar__day--selected {
    background-color: #FF7043; /* 選択した日をオレンジ色 */
    color: white;
}

/* 滑らかなトランジション */
.react-date-picker__inputGroup__input,
.react-date-picker__calendar {
    transition: background-color 0.3s ease, border-color 0.3s ease;
}

--- src\renderer\src\components\MyDatePicker\MyDatePicker.tsx ---
import DatePicker, {DatePickerProps} from "react-datepicker";
import "./datePickerStyle.css";

function MyDatePicker(props: DatePickerProps) {
    return <DatePicker {...props}/>
}

export default MyDatePicker;


--- src\renderer\src\components\SideBar\CommandBar.tsx ---
import {Box, HTMLChakraProps, IconButton, IconButtonProps, VStack} from "@chakra-ui/react";
import MenuIcon from "@mui/icons-material/Menu";
import Divider from "@mui/material/Divider";
import TimerOutlinedIcon from "@mui/icons-material/TimerOutlined";
import EditNoteIcon from "@mui/icons-material/EditNote";
import ChatBubbleIcon from "@mui/icons-material/ChatBubble";
import AddTaskIcon from "@mui/icons-material/AddTask";
import {useTheme} from "@mui/material/styles";
import {useMyDialog} from "../../context/DialogsContext";

interface AppBarProps extends HTMLChakraProps<"div"> {
    open?: boolean;
    drawerWidth: number;
    isVisible:boolean;
}
interface CommandBarProps extends AppBarProps{
    isVisible:boolean;
    handleDrawerOpen:() => void;
}


function AppBar({ open = false, drawerWidth, children,isVisible=false }:AppBarProps){
    const theme = useTheme();

    // 動的にスタイルを決定
    const marginLeft = open ? `${drawerWidth}px` : "0";
    const transition = open
        ? `${theme.transitions.duration.enteringScreen}ms ${theme.transitions.easing.easeOut}`
        : `${theme.transitions.duration.leavingScreen}ms ${theme.transitions.easing.sharp}`;

    return (
        <Box
            as="header"
            bg="transparent"
            color="#000000"
            boxShadow="none"
            transition={transition}
            width={"55px"}
            minHeight="100vh"
            height="100vh"
            marginLeft={marginLeft}
            display={!open?"flex":"none"}
            justifyContent="flex-end"
        >
            { isVisible?children:<></>}
        </Box>
    );
}


export function CommandBar(props:CommandBarProps) {
    const { openDialog } = useMyDialog();

    const sideBarIconButtonStyle :IconButtonProps ={
        size:"xl",
        textStyle:"xl",
        color:"orange.900",
        bg:{
            base: "transparent",
            _hover:"blackAlpha.200"
        }
    }

    return (
        <AppBar open={props.open} isVisible={props.isVisible} drawerWidth={props.drawerWidth}>
            <VStack>
                <IconButton
                    {...sideBarIconButtonStyle}
                    onClick={props.handleDrawerOpen}
                    display={props.open?'none':"block"}
                    variant={"subtle"}
                >
                    <MenuIcon />
                </IconButton>

                <Divider />

                {/*サイドバー*/}
                {/*ストップウォッチ*/}
                <IconButton {...sideBarIconButtonStyle} onClick={()=>openDialog("StopWatch")}>
                    <TimerOutlinedIcon/>
                </IconButton>

                {/*記録*/}
                <IconButton {...sideBarIconButtonStyle} onClick={()=>openDialog("AddLog")}>
                    <EditNoteIcon/>
                </IconButton>

                {/*タスクの追加*/}
                <IconButton {...sideBarIconButtonStyle} onClick={()=>openDialog("AddTask")}>
                    <ChatBubbleIcon/>
                </IconButton>

                {/*つぶやき*/}
                <IconButton {...sideBarIconButtonStyle} onClick={()=>openDialog("Tweet")}>
                    <AddTaskIcon/>
                </IconButton>
            </VStack>
        </AppBar>
    )
}

--- src\renderer\src\components\SideBar\CommandList.tsx ---
import List from "@mui/material/List";
import {For} from "@chakra-ui/react";
import TimerOutlinedIcon from "@mui/icons-material/TimerOutlined";
import EditNoteIcon from "@mui/icons-material/EditNote";
import ChatBubbleIcon from "@mui/icons-material/ChatBubble";
import AddTaskIcon from "@mui/icons-material/AddTask";
import {ListButton} from "./ListButton";
import {DialogType, useMyDialog} from "../../context/DialogsContext";

export function CommandList() {
    const { openDialog } = useMyDialog();
    return (
        <List>
            <For
                each={[
                    { name: "ストップウォッチ", icon:<TimerOutlinedIcon/>,dialog:"StopWatch"},
                    { name: "記録", icon:<EditNoteIcon/>,dialog:"AddLog"},
                    { name: "つぶやき", icon:<ChatBubbleIcon/>,dialog:"Tweet"},
                    { name: "タスクを追加", icon:<AddTaskIcon/>,dialog:"AddTask"},
                ]}
            >
                {(item) =>{
                    return (
                        <ListButton
                            key={`${item.dialog}_List`}
                            name={item.name}
                            icon={item.icon}
                            onClick={()=>openDialog(item.dialog as DialogType)}
                        />
                    );
                }}
            </For>
        </List>
    )
}

--- src\renderer\src\components\SideBar\ListButton.tsx ---
import * as React from "react";
import ListItem from "@mui/material/ListItem";
import ListItemButton from "@mui/material/ListItemButton";
import ListItemIcon from "@mui/material/ListItemIcon";
import ListItemText from "@mui/material/ListItemText";
import {Text} from "@chakra-ui/react";

interface Props {
    name:string
    icon:React.ReactElement
    onClick?:() => void
}

export function ListButton(props:Props) {
    return (
        <ListItem disablePadding onClick={props.onClick}>
            <ListItemButton>
                <ListItemIcon>
                    {props.icon}
                </ListItemIcon>
                <ListItemText
                    disableTypography
                    primary={<Text fontSize={"1.1em"}>{props.name}</Text>}
                />
            </ListItemButton>
        </ListItem>
    );
}

--- src\renderer\src\components\SideBar\MainViewer.tsx ---
import {Box, HTMLChakraProps} from "@chakra-ui/react";
import {useTheme} from "@mui/material/styles";

interface MainViewerProps extends HTMLChakraProps<"div">{
    open?: boolean;
    drawerWidth: number;
}

export function MainViewer({ open = false, drawerWidth, children,...other }:MainViewerProps){
    const theme = useTheme();
    const marginLeft = open ? 0 : `-${drawerWidth}px`;

    const transition = open
        ? `${theme.transitions.duration.enteringScreen}ms ${theme.transitions.easing.easeOut}`
        : `${theme.transitions.duration.leavingScreen}ms ${theme.transitions.easing.sharp}`;

    return (
        <Box
            flexGrow={1}
            h="100vh"
            transition={`margin ${transition}`}
            ml={marginLeft}
            pl={open?2:0}
            overflowY={"hidden"}
            {...other}
        >
            {children}
        </Box>
    );
}


--- src\renderer\src\context\DialogsContext.tsx ---
import { createContext, useContext, useState, ReactNode } from 'react';
import {StopWatch} from "../components/Dialogs/StopWatch";
import {Tweet} from "../components/Dialogs/Tweet";
import {AddTask} from "../components/Dialogs/AddTask";
import {AddLog} from "../components/Dialogs/AddLog";
import {useStopwatchContext} from "./StopwatchContext"; // カスタムダイアログコンポーネント

// ダイアログの種類を定義
export type DialogType = 'StopWatch' | 'AddLog' | 'AddTask' | 'Tweet';

// コンテキストの型定義
interface DialogContextType {
    dialogType: DialogType | null;
    dialogProps: any;
    openDialog: (type: DialogType, props?: any) => void;
    closeDialog: () => void;
}

// コンテキストの作成
const DialogContext = createContext<DialogContextType | null>(null);

// プロバイダーコンポーネント
export function DialogsProvider({ children }: { children: ReactNode }) {
    const [dialogType, setDialogType] = useState<DialogType | null>(null);
    const [dialogProps, setDialogProps] = useState<any>(null);
    const {  setIsMinimum  } = useStopwatchContext();

    const openDialog = (type: DialogType, props: any = {}) => {
        setDialogType(type);
        setDialogProps(props);
        if (type === 'StopWatch') {
            setIsMinimum(false);
        }
    };

    const closeDialog = () => {
        setDialogType(null);
        setDialogProps(null);
    };

    return (
        <DialogContext.Provider value={{ dialogType, dialogProps, openDialog, closeDialog }}>
            {children}
            <UnifiedDialog />
        </DialogContext.Provider>
    );
}

// ダイアログを操作するカスタムフック
export function useMyDialog() {
    const context = useContext(DialogContext);
    if (!context) {
        throw new Error('useDialog must be used within a DialogProvider');
    }
    return context;
}

// 汎用的なダイアログコンポーネント
function UnifiedDialog() {
    const { dialogType, dialogProps, closeDialog } = useMyDialog();

    if (!dialogType) return null;

    const renderDialogContent = () => {
        switch (dialogType) {
            case 'StopWatch':
                return <StopWatch {...dialogProps} closeDialog={closeDialog} isOpen={!!dialogType} />;
            case 'AddLog':
                return <AddLog {...dialogProps} closeDialog={closeDialog} isOpen={!!dialogType}/>;
            case 'AddTask':
                return <AddTask {...dialogProps} closeDialog={closeDialog} isOpen={!!dialogType}/>;
            case 'Tweet':
                return <Tweet {...dialogProps} closeDialog={closeDialog} isOpen={!!dialogType}/>;
            default:
                return null;
        }
    };

    return renderDialogContent();
}


--- src\renderer\src\context\StopwatchContext.tsx ---
import React, { useState, useRef, useEffect, useCallback, useContext, createContext } from 'react';

// ストップウォッチの状態を表す型
interface StopwatchState {
  isRunning : boolean;  // ストップウォッチが動作しているかどうか
  startTime : number;   // ストップウォッチが開始された時刻
  elapsed   : number;   // 経過時間
  isMinimum : boolean;  // ストップウォッチが最小化されているかどうか
}

// Context に保持するデータと操作を表す型
interface StopwatchContextType {
  currentTime: number;          // 現在の経過時間
  isRunning: boolean;           // ストップウォッチの状態（動作中かどうか）
  isMinimum: boolean;           // 最小化状態かどうか
  startStopwatch: () => void;   // ストップウォッチを開始する関数
  finishStopwatch: () => void;  // ストップウォッチを停止する関数
  resetStopwatch: (callback?:(currentTime:number)=>void) => void;  // ストップウォッチをリセットする関数
  setIsMinimum: (state:boolean) => void;  // 最小化状態を切り替える関数
}

// StopwatchContext を作成し、状態と操作を提供する
const StopwatchContext = createContext<StopwatchContextType | undefined>(undefined);

// カスタムフック: useStopwatchContext
// StopwatchContext からデータと操作を取得する
export const useStopwatchContext = (): StopwatchContextType => {
  const context = useContext(StopwatchContext);

  // コンテキストが正しく提供されていない場合はエラーをスロー
  if (!context) throw new Error('useStopwatchContext must be used within a StopwatchProvider');

  return context;
};

// ストップウォッチの状態と操作を提供する Provider コンポーネント
export const StopwatchProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  // ストップウォッチの状態を管理
  const [state, setState] = useState<StopwatchState>({
    isRunning: false,  // 初期状態では停止中
    startTime: 0,      // 初期の開始時刻は0
    elapsed  : 0,        // 初期の経過時間は0
    isMinimum: false,  // 初期状態では最小化されていない
  });

  // タイマーの参照
  const intervalRef = useRef<NodeJS.Timer | null>(null);

  // 現在の経過時間を計算
  const currentTime = state.isRunning
      ? state.elapsed + (Date.now() - state.startTime)  // ストップウォッチが動作中ならば、開始時刻から現在までの経過時間を加算
      : state.elapsed;  // 停止中は経過時間をそのまま使用

  // ストップウォッチを開始する関数
  const startStopwatch = useCallback(() => {
    // 既に動作中なら何もしない
    if (state.isRunning) return;

    // 動作中状態に更新し、開始時刻を現在の時刻に設定
    setState({
      isRunning : true,
      startTime : Date.now(),
      elapsed   : state.elapsed,
      isMinimum : state.isMinimum, // 最小化状態を保持
    });
  }, [state.isRunning, state.elapsed, state.isMinimum]);  // isRunning, elapsed, isMinimum が変更された時に再評価

  // ストップウォッチをリセットする関数
  const resetStopwatch = useCallback((callback?:(currentTime:number)=>void) => {
    callback!(currentTime);
    // 経過時間や開始時刻をリセット
    setState({
      isRunning: false,
      startTime: 0,
      elapsed: 0,
      isMinimum:false, // 最小化状態をリセット
    });
  }, [state.isMinimum]);  // isMinimum が変更された時に再評価

  // ストップウォッチ終了処理
  // 中身いじってね
  const finishStopwatch = useCallback(()=>{
    setIsMinimum(false);
    resetStopwatch((currentTime)=>{
      alert(currentTime)
    });
  },[]);

  // 最小化状態を設定する関数（引数にbooleanを受け取る）
  const setIsMinimum = useCallback((value: boolean) => {
    setState((prev) => ({
      ...prev,
      isMinimum: value,  // 引数に渡された値で最小化状態を設定
    }));
  }, []);

  // ストップウォッチが動作中のときだけ、一定間隔で状態を更新
  useEffect(() => {
    if (state.isRunning) {
      // 動作中なら、250ミリ秒ごとに状態を更新
      intervalRef.current = setInterval(() => setState((prev) => ({ ...prev })), 250);
    } else if (intervalRef.current) {
      // 停止中なら、インターバルをクリア
      clearInterval(intervalRef.current as unknown as number);
      intervalRef.current = null;
    }

    // クリーンアップ: コンポーネントがアンマウントされたときにインターバルをクリア
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current as unknown as number);
      }
    };
  }, [state.isRunning]);  // isRunning が変更されたときに再評価

  // Context に渡す値を準備
  const contextValue = {
    isRunning: state.isRunning,   // ストップウォッチの動作状態
    currentTime,                  // 現在の経過時間
    isMinimum: state.isMinimum,   // 最小化状態
    startStopwatch,               // ストップウォッチ開始関数
    finishStopwatch,              // ストップウォッチ停止関数
    resetStopwatch,               // ストップウォッチリセット関数
    setIsMinimum,                 // 最小化状態を切り替える関数
  };

  // StopwatchContext.Provider で子コンポーネントに状態を提供
  return <StopwatchContext.Provider value={contextValue}>{children}</StopwatchContext.Provider>;
};


--- src\renderer\src\context\TaskContext.tsx ---
import { createContext, useContext, useState, ReactNode } from 'react';

// タスクの型定義
export interface TaskItem {
    date_unix: number;
    task: string;
    task_hush:string, // date_unix-taskっていうふうにする
}
// ハッシュなし
export type TaskItemNoHush = Omit<TaskItem, 'task_hush'>;

// Context の型定義
interface TaskContextProps {
    taskData: TaskItem[]; // タスクの配列
    taskList: string[]; // タスク名のリスト
    taskNow: TaskItem | null; // 現在選択されているタスク
    addTask: (newTask: TaskItem[]) => boolean; // タスク追加関数
    taskNowHandler: (task:TaskItem|null)=>void; // 現在選択されたタスクを設定する関数
}

// ハッシュを生成する関数
export const generateTaskHash = (task:TaskItemNoHush|TaskItem): string => {
    // 簡易的にtaskの内容を基にハッシュを生成
    return `${task.date_unix}-${task.task}`;
};


// Context の初期値
const TaskContext = createContext<TaskContextProps | undefined>(undefined);

// Provider の作成
export const TaskProvider = ({ children }: { children: ReactNode }) => {
    const [taskData, setTaskData] = useState<TaskItem[]>([]); // タスク配列の状態管理
    const [taskNow, setTaskNow] = useState<TaskItem | null>(null); // 現在選択されているタスクの状態管理

    // タスク名リストを動的に取得
    const taskList = taskData.map((task) => task.task);

    const addTask = (newTasks: TaskItemNoHush|TaskItemNoHush[]) => {
        // 配列でない場合は配列に変換
        const tasksToAdd = Array.isArray(newTasks) ? newTasks : [newTasks];

        setTaskData((prev) => {
            // `Map` を使って既存のタスクを一意に保持する
            const taskMap = new Map(prev.map((task) => [generateTaskHash(task),task]));
            // 重複を除外した新しいタスクを取得
            tasksToAdd.forEach((newTask) => {
                taskMap.set(generateTaskHash(newTask),{...newTask,task_hush:generateTaskHash(newTask)})
            });
            // 新しいタスクを追加して更新
            return Array.from(taskMap.values());
        });
        return true;
    };
    const taskNowHandler = (task: TaskItem | null) => {
        setTaskNow(task);
    }
    return (
        <TaskContext.Provider value={{ taskData, taskList, taskNow, addTask,taskNowHandler }}>
            {children}
        </TaskContext.Provider>
    );
};

// Context を利用するカスタムフック
export const useTaskContext = () => {
    const context = useContext(TaskContext);
    if (!context) {
        throw new Error('useTaskContext must be used within a TaskProvider');
    }
    return context;
};


--- src\renderer\src\hooks\useWindowSize.ts ---
import { useSyncExternalStore } from "react";

type WindowSize = {
    windowWidth: number;
    windowHeight: number;
};

const getWindowWidth = () => {
    return window.innerWidth;
};
const getWindowHeight = () => {
    return window.innerHeight;
};

const subscribeWindowSizeChange = (callback: () => void) => {
    window.addEventListener("resize", callback);
    return () => window.removeEventListener("resize", callback);
};

export const useWindowSize = (): WindowSize => {
    const width = useSyncExternalStore(subscribeWindowSizeChange, getWindowWidth);
    const height = useSyncExternalStore(
        subscribeWindowSizeChange,
        getWindowHeight
    );
    return { windowWidth: width, windowHeight: height };
};

--- src\renderer\src\style\scroll.css ---
/* スクロールバー全体のデザイン */
::-webkit-scrollbar {
    width: 12px; /* 横スクロールバーの高さもここで指定される */
    height: 12px; /* 必要に応じて高さも設定 */
}

/* スクロールバーのトラック（背景部分） */
::-webkit-scrollbar-track {
    background: #f4f4f4;
    border-radius: 6px;
    border: 1px solid #dcdcdc;
}

/* スクロールバーのつまみ部分 */
::-webkit-scrollbar-thumb {
    background: #b87b3e;
    border-radius: 6px;
    border: 2px solid #f4f4f4;
}

/* スクロールバーのつまみ部分（ホバー時） */
::-webkit-scrollbar-thumb:hover {
    background: #8a5a32;
}

/* スクロールバーの角（四隅） */
::-webkit-scrollbar-corner {
    background: #f4f4f4;
}


--- src\renderer\src\test\tasktest.tsx ---
import { useState } from 'react';
import {Box, Button, Fieldset, Input} from '@chakra-ui/react';
import {Field} from "../ui/field";
import MyDatePicker from "../components/MyDatePicker/MyDatePicker";

export const TaskCreate = () => {
    const [taskName, setTaskName] = useState('');
    const [dueDate, setDueDate] = useState<Date|null>(null);
    // const { isOpen, onOpen, onClose } = useDisclosure();

    const handleTaskNameChange = (e) => setTaskName(e.target.value);
    const handleDueDateChange = (date) => setDueDate(date);

    const handleSubmit = () => {
        if (taskName && dueDate) {
            const dateUnix = Math.floor(dueDate.getTime() / 1000); // Unix timestamp (seconds)
            const taskData = { date_unix: dateUnix, task: taskName };
            console.log(taskData); // 送信されるデータ
            setTaskName(''); // フォームのリセット
            setDueDate(null);
        }
    };

    const handleCancel = () => {
        setTaskName('');
        setDueDate(null);
    };

    return (
        <Box
            p={6}
            w="400px"
            borderRadius="md"
            boxShadow="lg"
            bg="orange.50"
            maxW="lg"
            margin="auto"
        >
            <Fieldset.Root size="lg" maxW="md">
                <Fieldset.Content>
                    <Field label="タスク名">
                        <Input
                            value={taskName}
                            onChange={handleTaskNameChange}
                            placeholder="タスク名を入力"
                            size="lg"
                            bg="white"
                            borderColor="orange.200"
                            _hover={{ borderColor: 'orange.300' }}
                        />
                    </Field>
                    <Field label={"期限"}>
                        <MyDatePicker
                            selected={dueDate}
                            onChange={handleDueDateChange}
                            dateFormat="yyyy/MM/dd"
                            placeholderText="期限を選択"
                        />
                    </Field>
                </Fieldset.Content>
            </Fieldset.Root>
            <Box display="flex" justifyContent="space-between" w="100%">
                <Button
                    colorScheme="orange"
                    onClick={handleSubmit}
                    disabled={!taskName || !dueDate}
                    size="lg"
                >
                    送信する
                </Button>
                <Button
                    variant="outline"
                    colorScheme="orange"
                    onClick={handleCancel}
                    size="lg"
                >
                    キャンセル
                </Button>
            </Box>
        </Box>
    );
};

export default TaskCreate;


--- src\renderer\src\types\import-image.d.ts ---
declare module "*.png";
declare module "*.jpg";

--- src\renderer\src\ui\accordion.tsx ---
import {Accordion, HStack, HTMLChakraProps} from "@chakra-ui/react"
import * as React from "react"
import { LuChevronDown } from "react-icons/lu"

interface AccordionItemTriggerProps extends Accordion.ItemTriggerProps {
  indicatorPlacement?: "start" | "end"
}

export const AccordionItemTrigger = React.forwardRef<
  HTMLButtonElement,
  AccordionItemTriggerProps & HTMLChakraProps<"div">
>(function AccordionItemTrigger(props, ref) {
  const { children, indicatorPlacement = "end", ...rest } = props;
  return (
    <Accordion.ItemTrigger {...rest} ref={ref}>
      {indicatorPlacement === "start" && (
        <Accordion.ItemIndicator rotate={{ base: "-90deg", _open: "0deg" }}>
          <LuChevronDown />
        </Accordion.ItemIndicator>
      )}
      <HStack gap="4" flex="1" textAlign="start" width="full">
        {children}
      </HStack>
      {indicatorPlacement === "end" && (
        <Accordion.ItemIndicator>
          <LuChevronDown />
        </Accordion.ItemIndicator>
      )}
    </Accordion.ItemTrigger>
  )
})

interface AccordionItemContentProps extends Accordion.ItemContentProps {}

export const AccordionItemContent = React.forwardRef<
  HTMLDivElement,
  AccordionItemContentProps & HTMLChakraProps<"div">
>(function AccordionItemContent(props, ref) {
  return (
    <Accordion.ItemContent>
      <Accordion.ItemBody {...props} ref={ref} />
    </Accordion.ItemContent>
  )
})

export const AccordionRoot = Accordion.Root
export const AccordionItem = Accordion.Item


--- src\renderer\src\ui\avatar.tsx ---
"use client"

import type { GroupProps, SlotRecipeProps } from "@chakra-ui/react"
import { Avatar as ChakraAvatar, Group } from "@chakra-ui/react"
import * as React from "react"

type ImageProps = React.ImgHTMLAttributes<HTMLImageElement>

export interface AvatarProps extends ChakraAvatar.RootProps {
  name?: string
  src?: string
  srcSet?: string
  loading?: ImageProps["loading"]
  icon?: React.ReactElement
  fallback?: React.ReactNode
}

export const Avatar = React.forwardRef<HTMLDivElement, AvatarProps>(
  function Avatar(props, ref) {
    const { name, src, srcSet, loading, icon, fallback, children, ...rest } =
      props
    return (
      <ChakraAvatar.Root ref={ref} {...rest}>
        <AvatarFallback name={name} icon={icon}>
          {fallback}
        </AvatarFallback>
        <ChakraAvatar.Image src={src} srcSet={srcSet} loading={loading} />
        {children}
      </ChakraAvatar.Root>
    )
  },
)

interface AvatarFallbackProps extends ChakraAvatar.FallbackProps {
  name?: string
  icon?: React.ReactElement
}

const AvatarFallback = React.forwardRef<HTMLDivElement, AvatarFallbackProps>(
  function AvatarFallback(props, ref) {
    const { name, icon, children, ...rest } = props
    return (
      <ChakraAvatar.Fallback ref={ref} {...rest}>
        {children}
        {name != null && children == null && <>{getInitials(name)}</>}
        {name == null && children == null && (
          <ChakraAvatar.Icon asChild={!!icon}>{icon}</ChakraAvatar.Icon>
        )}
      </ChakraAvatar.Fallback>
    )
  },
)

function getInitials(name: string) {
  const names = name.trim().split(" ")
  const firstName = names[0] != null ? names[0] : ""
  const lastName = names.length > 1 ? names[names.length - 1] : ""
  return firstName && lastName
    ? `${firstName.charAt(0)}${lastName.charAt(0)}`
    : firstName.charAt(0)
}

interface AvatarGroupProps extends GroupProps, SlotRecipeProps<"avatar"> {}

export const AvatarGroup = React.forwardRef<HTMLDivElement, AvatarGroupProps>(
  function AvatarGroup(props, ref) {
    const { size, variant, borderless, ...rest } = props
    return (
      <ChakraAvatar.PropsProvider value={{ size, variant, borderless }}>
        <Group gap="0" spaceX="-3" ref={ref} {...rest} />
      </ChakraAvatar.PropsProvider>
    )
  },
)


--- src\renderer\src\ui\button.tsx ---
import type { ButtonProps as ChakraButtonProps } from "@chakra-ui/react"
import {
  AbsoluteCenter,
  Button as ChakraButton,
  Span,
  Spinner,
} from "@chakra-ui/react"
import * as React from "react"

interface ButtonLoadingProps {
  loading?: boolean
  loadingText?: React.ReactNode
}

export interface ButtonProps extends ChakraButtonProps, ButtonLoadingProps {}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  function Button(props, ref) {
    const { loading, disabled, loadingText, children, ...rest } = props
    return (
      <ChakraButton disabled={loading || disabled} ref={ref} {...rest}>
        {loading && !loadingText ? (
          <>
            <AbsoluteCenter display="inline-flex">
              <Spinner size="inherit" color="inherit" />
            </AbsoluteCenter>
            <Span opacity={0}>{children}</Span>
          </>
        ) : loading && loadingText ? (
          <>
            <Spinner size="inherit" color="inherit" />
            {loadingText}
          </>
        ) : (
          children
        )}
      </ChakraButton>
    )
  },
)


--- src\renderer\src\ui\checkbox.tsx ---
import { Checkbox as ChakraCheckbox } from "@chakra-ui/react"
import * as React from "react"

export interface CheckboxProps extends ChakraCheckbox.RootProps {
  icon?: React.ReactNode
  inputProps?: React.InputHTMLAttributes<HTMLInputElement>
  rootRef?: React.Ref<HTMLLabelElement>
}

export const Checkbox = React.forwardRef<HTMLInputElement, CheckboxProps>(
  function Checkbox(props, ref) {
    const { icon, children, inputProps, rootRef, ...rest } = props
    return (
      <ChakraCheckbox.Root ref={rootRef} {...rest}>
        <ChakraCheckbox.HiddenInput ref={ref} {...inputProps} />
        <ChakraCheckbox.Control>
          {icon || <ChakraCheckbox.Indicator />}
        </ChakraCheckbox.Control>
        {children != null && (
          <ChakraCheckbox.Label>{children}</ChakraCheckbox.Label>
        )}
      </ChakraCheckbox.Root>
    )
  },
)


--- src\renderer\src\ui\close-button.tsx ---
import type { ButtonProps } from "@chakra-ui/react"
import { IconButton as ChakraIconButton } from "@chakra-ui/react"
import * as React from "react"
import { LuX } from "react-icons/lu"

export type CloseButtonProps = ButtonProps

export const CloseButton = React.forwardRef<
  HTMLButtonElement,
  CloseButtonProps
>(function CloseButton(props, ref) {
  return (
    <ChakraIconButton variant="ghost" aria-label="Close" ref={ref} {...props}>
      {props.children ?? <LuX />}
    </ChakraIconButton>
  )
})


--- src\renderer\src\ui\color-mode.tsx ---
"use client"

import type { IconButtonProps } from "@chakra-ui/react"
import { ClientOnly, IconButton, Skeleton } from "@chakra-ui/react"
import { ThemeProvider, useTheme } from "next-themes"
import type { ThemeProviderProps } from "next-themes"
import * as React from "react"
import { LuMoon, LuSun } from "react-icons/lu"

export interface ColorModeProviderProps extends ThemeProviderProps {}

export function ColorModeProvider(props: ColorModeProviderProps) {
  return (
    <ThemeProvider attribute="class" disableTransitionOnChange {...props} />
  )
}

export function useColorMode() {
  const { resolvedTheme, setTheme } = useTheme()
  const toggleColorMode = () => {
    setTheme(resolvedTheme === "light" ? "dark" : "light")
  }
  return {
    colorMode: resolvedTheme,
    setColorMode: setTheme,
    toggleColorMode,
  }
}

export function useColorModeValue<T>(light: T, dark: T) {
  const { colorMode } = useColorMode()
  return colorMode === "light" ? light : dark
}

export function ColorModeIcon() {
  const { colorMode } = useColorMode()
  return colorMode === "light" ? <LuSun /> : <LuMoon />
}

interface ColorModeButtonProps extends Omit<IconButtonProps, "aria-label"> {}

export const ColorModeButton = React.forwardRef<
  HTMLButtonElement,
  ColorModeButtonProps
>(function ColorModeButton(props, ref) {
  const { toggleColorMode } = useColorMode()
  return (
    <ClientOnly fallback={<Skeleton boxSize="8" />}>
      <IconButton
        onClick={toggleColorMode}
        variant="ghost"
        aria-label="Toggle color mode"
        size="sm"
        ref={ref}
        {...props}
        css={{
          _icon: {
            width: "5",
            height: "5",
          },
        }}
      >
        <ColorModeIcon />
      </IconButton>
    </ClientOnly>
  )
})


--- src\renderer\src\ui\dialog.tsx ---
import {
  Dialog as ChakraDialog,
  Portal,
  DialogCloseTriggerProps,
} from "@chakra-ui/react"
import { CloseButton } from "./close-button"
import * as React from "react"
import {ButtonProps} from "./button";

declare module "@chakra-ui/react" {
  export interface DialogTriggerProps{
    children?: React.ReactNode,
    asChild?:boolean,
  }
}

interface DialogContentProps extends ChakraDialog.ContentProps {
  portalled?: boolean
  portalRef?: React.RefObject<HTMLElement>
  backdrop?: boolean,
  children?: React.ReactNode,
  asChild?: boolean,
}

export const DialogContent = React.forwardRef<
    HTMLDivElement,
    DialogContentProps
>(function DialogContent(props, ref) {
  const {
    children,
    portalled = true,
    portalRef,
    backdrop = true,
    ...rest
  } = props

  const DCP:DialogContentProps={
    children,
    asChild:false
  };

  return (
      <Portal disabled={!portalled} container={portalRef}>
        {backdrop && <ChakraDialog.Backdrop />}
        <ChakraDialog.Positioner>
          <ChakraDialog.Content ref={ref} {...DCP} {...rest} />
        </ChakraDialog.Positioner>
      </Portal>
  )
})


export const DialogCloseTrigger = React.forwardRef<
    HTMLButtonElement,
    ChakraDialog.CloseTriggerProps & ButtonProps
>(function DialogCloseTrigger(props, ref) {
  const {size,...other}=props;
  const DCTP :DialogCloseTriggerProps = {
    position:"absolute",
    top:"2",
    insetEnd:"2",
    asChild:true,
    children:(
        <CloseButton size={size ?? "md"} ref={ref}>
          {props.children}
        </CloseButton>
    )
  }
  return (<ChakraDialog.CloseTrigger {...DCTP} {...other}/>);
})

export const DialogRoot = ChakraDialog.Root
export const DialogFooter = ChakraDialog.Footer
export const DialogHeader = ChakraDialog.Header
export const DialogBody = ChakraDialog.Body
export const DialogBackdrop = ChakraDialog.Backdrop
export const DialogTitle = ChakraDialog.Title
export const DialogDescription = ChakraDialog.Description
export const DialogTrigger = ChakraDialog.Trigger
export const DialogActionTrigger = ChakraDialog.ActionTrigger


--- src\renderer\src\ui\drawer.tsx ---
import {Drawer as ChakraDrawer, HTMLChakraProps, Portal} from "@chakra-ui/react"
import { CloseButton } from "./close-button"
import * as React from "react"

interface DrawerContentProps extends ChakraDrawer.ContentProps {
  portalled?: boolean
  portalRef?: React.RefObject<HTMLElement>
  offset?: ChakraDrawer.ContentProps["padding"]
}

export const DrawerContent = React.forwardRef<
  HTMLDivElement,
  DrawerContentProps & HTMLChakraProps<"div">
>(function DrawerContent(props, ref) {
  const { children, portalled = true, portalRef, offset, ...rest } = props
  return (
    <Portal disabled={!portalled} container={portalRef}>
      <ChakraDrawer.Positioner padding={offset}>
        <ChakraDrawer.Content ref={ref} {...rest} asChild={false}>
          {children}
        </ChakraDrawer.Content>
      </ChakraDrawer.Positioner>
    </Portal>
  )
})

export const DrawerCloseTrigger = React.forwardRef<
  HTMLButtonElement,
  ChakraDrawer.CloseTriggerProps
>(function DrawerCloseTrigger(props, ref) {
  return (
    <ChakraDrawer.CloseTrigger
      position="absolute"
      top="2"
      insetEnd="2"
      {...props}
      asChild
    >
      <CloseButton size="sm" ref={ref} />
    </ChakraDrawer.CloseTrigger>
  )
})

export const DrawerTrigger = ChakraDrawer.Trigger
export const DrawerRoot = ChakraDrawer.Root
export const DrawerFooter = ChakraDrawer.Footer
export const DrawerHeader = ChakraDrawer.Header
export const DrawerBody = ChakraDrawer.Body
export const DrawerBackdrop = ChakraDrawer.Backdrop
export const DrawerDescription = ChakraDrawer.Description
export const DrawerTitle = ChakraDrawer.Title
export const DrawerActionTrigger = ChakraDrawer.ActionTrigger


--- src\renderer\src\ui\empty-state.tsx ---
import { EmptyState as ChakraEmptyState, VStack } from "@chakra-ui/react"
import * as React from "react"

export interface EmptyStateProps extends ChakraEmptyState.RootProps {
  title: string
  description?: string
  icon?: React.ReactNode
}

export const EmptyState = React.forwardRef<HTMLDivElement, EmptyStateProps>(
  function EmptyState(props, ref) {
    const { title, description, icon, children, ...rest } = props
    return (
      <ChakraEmptyState.Root ref={ref} {...rest}>
        <ChakraEmptyState.Content>
          {icon && (
            <ChakraEmptyState.Indicator>{icon}</ChakraEmptyState.Indicator>
          )}
          {description ? (
            <VStack textAlign="center">
              <ChakraEmptyState.Title>{title}</ChakraEmptyState.Title>
              <ChakraEmptyState.Description>
                {description}
              </ChakraEmptyState.Description>
            </VStack>
          ) : (
            <ChakraEmptyState.Title>{title}</ChakraEmptyState.Title>
          )}
          {children}
        </ChakraEmptyState.Content>
      </ChakraEmptyState.Root>
    )
  },
)


--- src\renderer\src\ui\field.tsx ---
import { Field as ChakraField } from "@chakra-ui/react"
import * as React from "react"

export interface FieldProps extends Omit<ChakraField.RootProps, "label"> {
  label?: React.ReactNode
  helperText?: React.ReactNode
  errorText?: React.ReactNode
  optionalText?: React.ReactNode
}

export const Field = React.forwardRef<HTMLDivElement, FieldProps>(
  function Field(props, ref) {
    const { label, children, helperText, errorText, optionalText, ...rest } =
      props
    return (
      <ChakraField.Root ref={ref} {...rest}>
        {label && (
          <ChakraField.Label>
            {label}
            <ChakraField.RequiredIndicator fallback={optionalText} />
          </ChakraField.Label>
        )}
        {children}
        {helperText && (
          <ChakraField.HelperText>{helperText}</ChakraField.HelperText>
        )}
        {errorText && (
          <ChakraField.ErrorText>{errorText}</ChakraField.ErrorText>
        )}
      </ChakraField.Root>
    )
  },
)


--- src\renderer\src\ui\input-group.tsx ---
import type { BoxProps, InputElementProps } from "@chakra-ui/react"
import { Group, InputElement } from "@chakra-ui/react"
import * as React from "react"

export interface InputGroupProps extends BoxProps {
  startElementProps?: InputElementProps
  endElementProps?: InputElementProps
  startElement?: React.ReactNode
  endElement?: React.ReactNode
  children: React.ReactElement<InputElementProps>
  startOffset?: InputElementProps["paddingStart"]
  endOffset?: InputElementProps["paddingEnd"]
}

export const InputGroup = React.forwardRef<HTMLDivElement, InputGroupProps>(
  function InputGroup(props, ref) {
    const {
      startElement,
      startElementProps,
      endElement,
      endElementProps,
      children,
      startOffset = "6px",
      endOffset = "6px",
      ...rest
    } = props

    const child =
      React.Children.only<React.ReactElement<InputElementProps>>(children)

    return (
      <Group ref={ref} {...rest}>
        {startElement && (
          <InputElement pointerEvents="none" {...startElementProps}>
            {startElement}
          </InputElement>
        )}
        {React.cloneElement(child, {
          ...(startElement && {
            ps: `calc(var(--input-height) - ${startOffset})`,
          }),
          ...(endElement && { pe: `calc(var(--input-height) - ${endOffset})` }),
          ...children.props,
        })}
        {endElement && (
          <InputElement placement="end" {...endElementProps}>
            {endElement}
          </InputElement>
        )}
      </Group>
    )
  },
)


--- src\renderer\src\ui\popover.tsx ---
import { Popover as ChakraPopover, Portal } from "@chakra-ui/react"
import { CloseButton } from "./close-button"
import * as React from "react"

interface PopoverContentProps extends ChakraPopover.ContentProps {
  portalled?: boolean
  portalRef?: React.RefObject<HTMLElement>
}

export const PopoverContent = React.forwardRef<
  HTMLDivElement,
  PopoverContentProps
>(function PopoverContent(props, ref) {
  const { portalled = true, portalRef, ...rest } = props
  return (
    <Portal disabled={!portalled} container={portalRef}>
      <ChakraPopover.Positioner>
        <ChakraPopover.Content ref={ref} {...rest} />
      </ChakraPopover.Positioner>
    </Portal>
  )
})

export const PopoverArrow = React.forwardRef<
  HTMLDivElement,
  ChakraPopover.ArrowProps
>(function PopoverArrow(props, ref) {
  return (
    <ChakraPopover.Arrow {...props} ref={ref}>
      <ChakraPopover.ArrowTip />
    </ChakraPopover.Arrow>
  )
})

export const PopoverCloseTrigger = React.forwardRef<
  HTMLButtonElement,
  ChakraPopover.CloseTriggerProps
>(function PopoverCloseTrigger(props, ref) {
  return (
    <ChakraPopover.CloseTrigger
      position="absolute"
      top="1"
      insetEnd="1"
      {...props}
      asChild
      ref={ref}
    >
      <CloseButton size="sm" />
    </ChakraPopover.CloseTrigger>
  )
})

export const PopoverTitle = ChakraPopover.Title
export const PopoverDescription = ChakraPopover.Description
export const PopoverFooter = ChakraPopover.Footer
export const PopoverHeader = ChakraPopover.Header
export const PopoverRoot = ChakraPopover.Root
export const PopoverBody = ChakraPopover.Body
export const PopoverTrigger = ChakraPopover.Trigger


--- src\renderer\src\ui\provider.tsx ---
"use client"

import {ChakraProvider, createSystem, defaultConfig, SystemContext} from "@chakra-ui/react"
import {
  ColorModeProvider,
  type ColorModeProviderProps,
} from "./color-mode"

export function Provider(props: ColorModeProviderProps&{system?:SystemContext}) {

  return (
    <ChakraProvider value={props.system ?? createSystem(defaultConfig)}>
      <ColorModeProvider {...props} />
    </ChakraProvider>
  )
}


--- src\renderer\src\ui\radio.tsx ---
import { RadioGroup as ChakraRadioGroup } from "@chakra-ui/react"
import * as React from "react"

export interface RadioProps extends ChakraRadioGroup.ItemProps {
  rootRef?: React.Ref<HTMLDivElement>;
  inputProps?: React.InputHTMLAttributes<HTMLInputElement>;
  children?: React.ReactNode
}

export const Radio = React.forwardRef<HTMLInputElement, RadioProps>(
  function Radio(props, ref) {
    const { children, inputProps, rootRef, ...rest } = props;
    return (
      <ChakraRadioGroup.Item ref={rootRef} {...rest}>
          <ChakraRadioGroup.ItemHiddenInput ref={ref} {...inputProps} />
          <ChakraRadioGroup.ItemIndicator />
          {children && (
              <ChakraRadioGroup.ItemText>{children}</ChakraRadioGroup.ItemText>
          )}
      </ChakraRadioGroup.Item>
    )
  },
)

export const RadioGroup = ChakraRadioGroup.Root


--- src\renderer\src\ui\select.tsx ---
"use client"

import type { CollectionItem } from "@chakra-ui/react"
import { Select as ChakraSelect, Portal } from "@chakra-ui/react"
import { CloseButton } from "./src/components/ui/close-button"
import * as React from "react"

interface SelectTriggerProps extends ChakraSelect.ControlProps {
  clearable?: boolean
}

export const SelectTrigger = React.forwardRef<
  HTMLButtonElement,
  SelectTriggerProps
>(function SelectTrigger(props, ref) {
  const { children, clearable, ...rest } = props
  return (
    <ChakraSelect.Control {...rest}>
      <ChakraSelect.Trigger ref={ref}>{children}</ChakraSelect.Trigger>
      <ChakraSelect.IndicatorGroup>
        {clearable && <SelectClearTrigger />}
        <ChakraSelect.Indicator />
      </ChakraSelect.IndicatorGroup>
    </ChakraSelect.Control>
  )
})

const SelectClearTrigger = React.forwardRef<
  HTMLButtonElement,
  ChakraSelect.ClearTriggerProps
>(function SelectClearTrigger(props, ref) {
  return (
    <ChakraSelect.ClearTrigger asChild {...props} ref={ref}>
      <CloseButton
        size="xs"
        variant="plain"
        focusVisibleRing="inside"
        focusRingWidth="2px"
        pointerEvents="auto"
      />
    </ChakraSelect.ClearTrigger>
  )
})

interface SelectContentProps extends ChakraSelect.ContentProps {
  portalled?: boolean
  portalRef?: React.RefObject<HTMLElement>
}

export const SelectContent = React.forwardRef<
  HTMLDivElement,
  SelectContentProps
>(function SelectContent(props, ref) {
  const { portalled = true, portalRef, ...rest } = props
  return (
    <Portal disabled={!portalled} container={portalRef}>
      <ChakraSelect.Positioner>
        <ChakraSelect.Content {...rest} ref={ref} />
      </ChakraSelect.Positioner>
    </Portal>
  )
})

export const SelectItem = React.forwardRef<
  HTMLDivElement,
  ChakraSelect.ItemProps
>(function SelectItem(props, ref) {
  const { item, children, ...rest } = props
  return (
    <ChakraSelect.Item key={item.value} item={item} {...rest} ref={ref}>
      {children}
      <ChakraSelect.ItemIndicator />
    </ChakraSelect.Item>
  )
})

interface SelectValueTextProps
  extends Omit<ChakraSelect.ValueTextProps, "children"> {
  children?(items: CollectionItem[]): React.ReactNode
}

export const SelectValueText = React.forwardRef<
  HTMLSpanElement,
  SelectValueTextProps
>(function SelectValueText(props, ref) {
  const { children, ...rest } = props
  return (
    <ChakraSelect.ValueText {...rest} ref={ref}>
      <ChakraSelect.Context>
        {(select) => {
          const items = select.selectedItems
          if (items.length === 0) return props.placeholder
          if (children) return children(items)
          if (items.length === 1)
            return select.collection.stringifyItem(items[0])
          return `${items.length} selected`
        }}
      </ChakraSelect.Context>
    </ChakraSelect.ValueText>
  )
})

export const SelectRoot = React.forwardRef<
  HTMLDivElement,
  ChakraSelect.RootProps
>(function SelectRoot(props, ref) {
  return (
    <ChakraSelect.Root
      {...props}
      ref={ref}
      positioning={{ sameWidth: true, ...props.positioning }}
    >
      {props.asChild ? (
        props.children
      ) : (
        <>
          <ChakraSelect.HiddenSelect />
          {props.children}
        </>
      )}
    </ChakraSelect.Root>
  )
}) as ChakraSelect.RootComponent

interface SelectItemGroupProps extends ChakraSelect.ItemGroupProps {
  label: React.ReactNode
}

export const SelectItemGroup = React.forwardRef<
  HTMLDivElement,
  SelectItemGroupProps
>(function SelectItemGroup(props, ref) {
  const { children, label, ...rest } = props
  return (
    <ChakraSelect.ItemGroup {...rest} ref={ref}>
      <ChakraSelect.ItemGroupLabel>{label}</ChakraSelect.ItemGroupLabel>
      {children}
    </ChakraSelect.ItemGroup>
  )
})

export const SelectLabel = ChakraSelect.Label
export const SelectItemText = ChakraSelect.ItemText


--- src\renderer\src\ui\slider.tsx ---
import { Slider as ChakraSlider, For, HStack } from "@chakra-ui/react"
import * as React from "react"

export interface SliderProps extends ChakraSlider.RootProps {
  marks?: Array<number | { value: number; label: React.ReactNode }>
  label?: React.ReactNode
  showValue?: boolean
}

export const Slider = React.forwardRef<HTMLDivElement, SliderProps>(
  function Slider(props, ref) {
    const { marks: marksProp, label, showValue, ...rest } = props
    const value = props.defaultValue ?? props.value

    const marks = marksProp?.map((mark) => {
      if (typeof mark === "number") return { value: mark, label: undefined }
      return mark
    })

    const hasMarkLabel = !!marks?.some((mark) => mark.label)

    return (
      <ChakraSlider.Root ref={ref} thumbAlignment="center" {...rest}>
        {label && !showValue && (
          <ChakraSlider.Label>{label}</ChakraSlider.Label>
        )}
        {label && showValue && (
          <HStack justify="space-between">
            <ChakraSlider.Label>{label}</ChakraSlider.Label>
            <ChakraSlider.ValueText />
          </HStack>
        )}
        <ChakraSlider.Control data-has-mark-label={hasMarkLabel || undefined}>
          <ChakraSlider.Track>
            <ChakraSlider.Range />
          </ChakraSlider.Track>
          <SliderThumbs value={value} />
          <SliderMarks marks={marks} />
        </ChakraSlider.Control>
      </ChakraSlider.Root>
    )
  },
)

function SliderThumbs(props: { value?: number[] }) {
  const { value } = props
  return (
    <For each={value}>
      {(_, index) => (
        <ChakraSlider.Thumb key={index} index={index}>
          <ChakraSlider.HiddenInput />
        </ChakraSlider.Thumb>
      )}
    </For>
  )
}

interface SliderMarksProps {
  marks?: Array<number | { value: number; label: React.ReactNode }>
}

const SliderMarks = React.forwardRef<HTMLDivElement, SliderMarksProps>(
  function SliderMarks(props, ref) {
    const { marks } = props
    if (!marks?.length) return null

    return (
      <ChakraSlider.MarkerGroup ref={ref}>
        {marks.map((mark, index) => {
          const value = typeof mark === "number" ? mark : mark.value
          const label = typeof mark === "number" ? undefined : mark.label
          return (
            <ChakraSlider.Marker key={index} value={value}>
              <ChakraSlider.MarkerIndicator />
              {label}
            </ChakraSlider.Marker>
          )
        })}
      </ChakraSlider.MarkerGroup>
    )
  },
)


--- src\renderer\src\ui\timeline.tsx ---
import { Timeline as ChakraTimeline } from "@chakra-ui/react"
import * as React from "react"

export const TimelineConnector = React.forwardRef<
  HTMLDivElement,
  ChakraTimeline.IndicatorProps
>(function TimelineConnector(props, ref) {
  return (
    <ChakraTimeline.Connector ref={ref}>
      <ChakraTimeline.Separator borderColor={"gray.300"} borderWidth={"1px"} />
      <ChakraTimeline.Indicator {...props} />
    </ChakraTimeline.Connector>
  )
})

export const TimelineRoot = ChakraTimeline.Root
export const TimelineContent = ChakraTimeline.Content
export const TimelineItem = ChakraTimeline.Item
export const TimelineIndicator = ChakraTimeline.Indicator
export const TimelineTitle = ChakraTimeline.Title
export const TimelineDescription = ChakraTimeline.Description


--- src\renderer\src\ui\tooltip.tsx ---
import { Tooltip as ChakraTooltip, Portal } from "@chakra-ui/react"
import * as React from "react"

export interface TooltipProps extends ChakraTooltip.RootProps {
  showArrow?: boolean
  portalled?: boolean
  portalRef?: React.RefObject<HTMLElement>
  content: React.ReactNode
  contentProps?: ChakraTooltip.ContentProps
  disabled?: boolean
}

export const Tooltip = React.forwardRef<HTMLDivElement, TooltipProps>(
  function Tooltip(props, ref) {
    const {
      showArrow,
      children,
      disabled,
      portalled,
      content,
      contentProps,
      portalRef,
      ...rest
    } = props

    if (disabled) return children

    return (
      <ChakraTooltip.Root {...rest}>
        <ChakraTooltip.Trigger asChild>{children}</ChakraTooltip.Trigger>
        <Portal disabled={!portalled} container={portalRef}>
          <ChakraTooltip.Positioner>
            <ChakraTooltip.Content ref={ref} {...contentProps}>
              {showArrow && (
                <ChakraTooltip.Arrow>
                  <ChakraTooltip.ArrowTip />
                </ChakraTooltip.Arrow>
              )}
              {content}
            </ChakraTooltip.Content>
          </ChakraTooltip.Positioner>
        </Portal>
      </ChakraTooltip.Root>
    )
  },
)


--- src\renderer\src\ui\src\components\ui\close-button.tsx ---
import type { ButtonProps } from "@chakra-ui/react"
import { IconButton as ChakraIconButton } from "@chakra-ui/react"
import * as React from "react"
import { LuX } from "react-icons/lu"

export type CloseButtonProps = ButtonProps

export const CloseButton = React.forwardRef<
  HTMLButtonElement,
  CloseButtonProps
>(function CloseButton(props, ref) {
  return (
    <ChakraIconButton variant="ghost" aria-label="Close" ref={ref} {...props}>
      {props.children ?? <LuX />}
    </ChakraIconButton>
  )
})


--- src\renderer\src\util\calcElapsedTime.tsx ---

// UNIXタイムスタンプの差分（秒単位）を受け取り
function calcElapsedTime(start: number, stop:number) {
    const timestamp = stop - start;
    const hours = Math.floor(timestamp / 3600);
    const minutes = Math.floor((timestamp % 3600) / 60);
    const seconds = timestamp % 60;

    let timeString = "";
    if (hours > 1) {
        timeString += `${hours}時間`;
    }
    if (minutes > 1) {
        timeString += `${minutes}分`
    }
    return `${timeString}${seconds}秒`;
}

export default calcElapsedTime;


--- src\renderer\src\util\convUnixOnlyDate.ts ---
export function convUnixOnlyDate(date_unix: number) {
    const nowDate = new Date(date_unix);
    const month = `${nowDate.getMonth() + 1}`.padStart(2, "0");
    const date = `${nowDate.getDate()}`.padStart(2, "0");
    return `${month}月${date}日`;
}

--- src\renderer\src\util\convUnixToIso.tsx ---
import { format } from 'date-fns';


const convUnixToIso = (value:number) => {
    // UNIXタイムスタンプを Date オブジェクトに変換
    const date = new Date(value);
    return format(date, 'yyyy-MM-dd HH:mm:ss');
};

export default convUnixToIso;


--- src\renderer\src\util\formatStopWatchTime.ts ---
// 時間のフォーマット
// ミリ秒をhh:mm:ssに変換
export const formatStopWatchTime = (time: number) => {
    // 分秒に変換
    const totalSeconds = Math.floor(time / 1000);
    const seconds = totalSeconds % 60;
    const minutes = Math.floor(totalSeconds / 60);
    const hours = Math.floor(minutes / 60);

    const hours_str = `${String(hours).padStart(2, "0")}`;
    const minutes_str = `${String(minutes).padStart(2, "0")}`;
    const seconds_str = `${String(seconds).padStart(2, "0")}`;

    return `${hours_str}:${minutes_str}:${seconds_str}`;
};


--- src\renderer\src\util\getImage.ts ---
export function getImage(fileName: string) {
   return new URL(`../assets/${fileName}`, import.meta.url).href
}

